// const replace = require("gulp-replace");

define(function (require) {
  const slingrWS = require("./slingr");
  let defaultJson = {
    id: "container0",
    type: "container",
    visible: true,
    layout: {
      display: "block",
      flexDirection: "row",
      flexWrap: "wrap",
      justifyContent: "center",
      flexShrink: 1,
      gap: "10px",
      columnPosition: "center",
      alignItems: "center",
      paddingTop: "20px",
      paddingBottom: "20px",
      paddingLeft: "20px",
      paddingRight: "20px",
    },
    style: {
      minWidth: "300px",
      width: "100%",
      minHeight: "505px",
      backgroundColor: "#F5F5DC",
      borderStyle: "dotted",
      borderColor: "black",
    },
    widgets: [
      {
        id: "container1",
        type: "container",
        visible: true,
        layout: {
          display: "block",
          flexDirection: "row",
          flexWrap: "wrap",
          justifyContent: "center",
          flexShrink: 1,
          gap: "10px",
          columnPosition: "center",
          alignItems: "center",
          paddingTop: "10px",
          paddingBottom: "10px",
          paddingLeft: "10px",
          paddingRight: "10px",
          marginBottom: "20px",
        },
        style: {
          width: "100%",
          backgroundColor: "#F5F5DC",
          borderStyle: "dotted",
        },
        widgets: [
          {
            id: "text1",
            type: "h2",
            text: "Testing fetching records",
            bindingType: "computed",
            visible: true,
            layout: {},
            style: {
              borderStyle: "solid",
              borderColor: "black",
            },
            font: {},
          },
        ],
      },
      {
        id: "people",
        type: "table",
        data: "{{people}}",
        visible: true,
        layout: {
          paddingTop: "10px",
          paddingBottom: "10px",
          paddingLeft: "10px",
          paddingRight: "10px",
          marginTop: "10",
          marginBottom: "20px",
          marginLeft: "auto",
          marginRight: "auto",
        },
        style: {
          minWidth: "",
          maxWidth: "",
          width: "80%",
          height: "",
          // backgroundColor: "#F5F5DC",
          // borderStyle: "dotted",
        },
        properties: {
          // tableTypes: ["table-bordered", "table-hover"],
          tableTypes: [
            "table-vmiddle",
            "table-hover",
            "bootgrid-table",
            "table-striped",
            "table-striped-column",
          ],
          // table table-vmiddle bootgrid-table table-hover table-striped table-striped-column
          columns: [
            {
              id: "text1",
              type: "th",
              header: {
                id: "text2",
                type: "th",
                layout: {
                  verticalAlign: "middle",
                },
                style: {},
                widgets: [
                  {
                    id: "text1",
                    type: "span",
                    text: "First Name",
                    visible: true,
                    layout: {},
                    style: {},
                    font: {},
                  },
                ],
              },
              cell: {
                id: "blabla",
                type: "td",
                layout: {
                  verticalAlign: "middle",
                },
                style: {},
                widgets: [
                  {
                    id: "text1",
                    type: "span",
                    text: "{{firstName}}",
                    visible: true,
                    layout: {},
                    style: {},
                    font: {
                      fontWeight: "bold",
                    },
                  },
                ],
              },
            },
            {
              id: "text2",
              header: {
                id: "text2",
                type: "th",
                layout: {},
                style: {},
                widgets: [
                  {
                    id: "text1",
                    type: "span",
                    text: "Last Name",
                    visible: true,
                    layout: {},
                    style: {},
                    font: {},
                  },
                ],
              },
              cell: {
                id: "text1",
                type: "td",
                layout: {
                  verticalAlign: "middle",
                },
                style: {},
                widgets: [
                  {
                    id: "text1",
                    text: "{{lastName}}",
                    type: "span",
                    visible: true,
                    layout: {},
                    style: {},
                    font: {},
                  },
                ],
              },
            },
            {
              id: "X",
              header: {
                id: "X",
                type: "th",
                layout: {
                  flexShrink: 0,
                },
                style: {
                  minWidth: "90px",
                  width: "90px",
                },
                widgets: [],
              },
              cell: {
                id: "lossesTD",
                type: "td",
                layout: {
                  display: "flex",
                  gap: "5px",
                  flexShrink: 0,
                },
                style: {
                  minWidth: "170px",
                },
                widgets: [
                  {
                    id: "slingrButton1",
                    type: "slingrWidget",
                    visible: true,
                    properties: {
                      kind: "button",
                      color: "danger",
                      click: "{{removeItem}}",
                      id: "slingrButton",
                      text: "",
                      icon: "zmdi-close",
                      disabled: false,
                    },
                    layout: {},
                    style: {},
                  },
                  {
                    id: "slingrButton1",
                    type: "slingrWidget",
                    visible: true,
                    properties: {
                      kind: "button",
                      color: "warning",
                      click: "{{changeName}}",
                      id: "slingrButton",
                      text: "",
                      icon: "zmdi-rotate-left",
                      disabled: false,
                    },
                    layout: {},
                    style: {},
                  },
                  {
                    id: "slingrButton1",
                    type: "slingrWidget",
                    visible: true,
                    properties: {
                      kind: "button",
                      color: "success",
                      click: "{{displayFirstName}}",
                      id: "slingrButton",
                      text: "",
                      icon: "zmdi-live-tv",
                      disabled: false,
                    },
                    layout: {},
                    style: {},
                  },
                ],
              },
            },
          ],
        },
      },
      {
        id: "inputTextSlingr",
        type: "slingrWidget",
        visible: true,
        properties: {
          kind: "inputText",
          id: "titleInput",
          placeholder: "Number of records",
          value: "{{inputValue}}",
          password: null,
          icon: null,
          maxLength: 10,
        },
        layout: {},
        style: {
          width: "50%",
        },
      },
      {
        id: "slingrButton1",
        type: "slingrWidget",
        visible: true,
        properties: {
          kind: "button",
          color: "info",
          click: "{{addEntry}}",
          id: "slingrButton",
          text: "Add Entry",
          icon: "zmdi-home",
          disabled: false,
        },
        layout: {
          marginTop: "10px",
        },
        style: {
          width: "50%",
        },
      },
      {
        id: "slingrButton1",
        type: "slingrWidget",
        visible: true,
        properties: {
          kind: "button",
          color: "info",
          click: "{{fetchRecords}}",
          id: "slingrButton",
          text: "Fetch Records",
          icon: "zmdi-home",
          disabled: false,
        },
        layout: {
          marginTop: "10px",
        },
        style: {
          width: "50%",
        },
      },
      {
        id: "container1",
        type: "container",
        visible: true,
        layout: {
          display: "flex",
          flexDirection: "row",
          flexWrap: "wrap",
          justifyContent: "center",
          flexShrink: 1,
          gap: "10px",
          columnPosition: "center",
          alignItems: "center",
          paddingTop: "10px",
          paddingBottom: "10px",
          paddingLeft: "10px",
          paddingRight: "10px",
          marginBottom: "20px",
        },
        style: {
          width: "100%",
          backgroundColor: "#F5F5DC",
          borderStyle: "dotted",
        },
        widgets: [
          {
            id: "text1",
            type: "span",
            text: "NÂ° of people: ",
            visible: true,
            layout: {},
            style: {},
            font: {},
          },
          {
            id: "text1",
            type: "span",
            text: "{{people.length}}",
            visible: true,
            layout: {
              paddingLeft: "3px",
              paddingRight: "3px",
              paddingTop: "3px",
              paddingBottom: "3px",
            },
            style: {
              borderStyle: "solid",
              borderColor: "black",
            },
            font: {},
          },
        ],
      },
      {
        id: "container1",
        type: "container",
        if: "{{activePersonID}}",
        visible: true,
        layout: {
          display: "flex",
          flexDirection: "row",
          flexWrap: "wrap",
          justifyContent: "center",
          flexShrink: 1,
          gap: "10px",
          columnPosition: "center",
          alignItems: "center",
          paddingTop: "10px",
          paddingBottom: "10px",
          paddingLeft: "10px",
          paddingRight: "10px",
          marginBottom: "20px",
        },
        style: {
          width: "100%",
          backgroundColor: "#F5F5DC",
          borderStyle: "dotted",
        },
        widgets: [
          // {
          //   id: "readOnlyRecord",
          //   type: "readOnly",
          //   recordId: "{{activePersonID}}",
          //   output: {
          //     record: "editRecord",
          //   },
          //   visible: true,
          //   layout: {
          //     display: "block",
          //     flexDirection: "row",
          //     flexWrap: "wrap",
          //     justifyContent: "center",
          //     flexShrink: 1,
          //     gap: "10px",
          //     columnPosition: "center",
          //     alignItems: "center",
          //     paddingTop: "10px",
          //     paddingBottom: "10px",
          //     paddingLeft: "10px",
          //     paddingRight: "10px",
          //     marginTop: "10",
          //     marginBottom: "20px",
          //     marginLeft: "auto",
          //     marginRight: "auto",
          //   },
          //   style: {
          //     minWidth: "",
          //     maxWidth: "",
          //     width: "80%",
          //     height: "400px",
          //     backgroundColor: "#F5F5DC",
          //     borderStyle: "dotted",
          //   },
          // },
          {
            id: "edit",
            type: "edit",
            recordId: "{{activePersonID}}",
            output: {
              record: "editRecord",
            },
            visible: true,
            layout: {
              display: "block",
              flexDirection: "row",
              flexWrap: "wrap",
              justifyContent: "center",
              flexShrink: 1,
              gap: "10px",
              columnPosition: "center",
              alignItems: "center",
              paddingTop: "10px",
              paddingBottom: "10px",
              paddingLeft: "10px",
              paddingRight: "10px",
              marginTop: "10",
              marginBottom: "20px",
              marginLeft: "auto",
              marginRight: "auto",
            },
            style: {
              minWidth: "",
              maxWidth: "",
              width: "80%",
              height: "400px",
              backgroundColor: "#F5F5DC",
              borderStyle: "dotted",
            },
          },
          // {
          //   id: "recordContainer",
          //   type: "recordContainer",
          //   subtype: "edit",
          //   recordId: "{{activePersonID}}",
          //   output: {
          //     record: "personRecord",
          //   },
          //   visible: true,
          //   layout: {
          //     display: "block",
          //     flexDirection: "row",
          //     flexWrap: "wrap",
          //     justifyContent: "center",
          //     flexShrink: 1,
          //     gap: "10px",
          //     columnPosition: "center",
          //     alignItems: "center",
          //     paddingTop: "10px",
          //     paddingBottom: "10px",
          //     paddingLeft: "10px",
          //     paddingRight: "10px",
          //     marginTop: "10",
          //     marginBottom: "20px",
          //     marginLeft: "auto",
          //     marginRight: "auto",
          //   },
          //   style: {
          //     minWidth: "",
          //     maxWidth: "",
          //     width: "80%",
          //     height: "400px",
          //     backgroundColor: "#F5F5DC",
          //     borderStyle: "dotted",
          //   },
          //   widgets: [
          //     {
          //       id: "text1",
          //       type: "recordField",
          //       field: "firstName",
          //       visible: true,
          //       layout: {
          //         paddingLeft: "3px",
          //         paddingRight: "3px",
          //         paddingTop: "3px",
          //         paddingBottom: "3px",
          //         marginLeft: "auto",
          //         marginRight: "auto",
          //       },
          //       style: {
          //         width: "50%",
          //         borderStyle: "solid",
          //         borderColor: "red",
          //       },
          //       properties: {},
          //     },
          //     {
          //       id: "text1",
          //       type: "recordField",
          //       field: "firstName",
          //       visible: true,
          //       layout: {
          //         paddingLeft: "3px",
          //         paddingRight: "3px",
          //         paddingTop: "3px",
          //         paddingBottom: "3px",
          //         marginLeft: "auto",
          //         marginRight: "auto",
          //       },
          //       style: {
          //         width: "50%",
          //         borderStyle: "solid",
          //         borderColor: "red",
          //       },
          //       properties: {},
          //     },
          //     {
          //       id: "slingrButton1",
          //       type: "slingrWidget",
          //       visible: true,
          //       properties: {
          //         kind: "button",
          //         color: "danger",
          //         click: "{{showModel}}",
          //         id: "slingrButton",
          //         text: "Show Model",
          //         icon: "zmdi-close",
          //         disabled: false,
          //       },
          //       layout: {},
          //       style: {},
          //     },
          //   ],
          // },
        ],
      },
    ],
  };

  var modelDefinition = [
    {
      id: "people",
      type: "array",
      elementsType: "record",
      query: {
        entity: "sys.users",
        size: 5,
      },
      nestedFields: [],
    },
    {
      id: "activePersonID",
      type: "string",
    },
    {
      id: "activePerson",
      type: "model",
      nestedFields: [],
    },
    {
      id: "inputValue",
      type: "number",
    },
    {
      id: "fetchRecords",
      type: "function",
      handler:
        "slingr.ws.get({ url: '/data/sys.users', params: { _size: model.inputValue } }, function (res) {  model.people = res.items; });",
    },
    {
      id: "addEntry",
      type: "function",
      handler:
        "model.people.push({firstName: model.inputValue  ,lastName:'TEST',earnings: 2, losses: 3, pets: [{dogName: 'pocha'}, {dogName: 'tara'}]});",
    },
    {
      id: "removeItem",
      type: "function",
      handler: "model.people.splice($index, 1);",
    },
    {
      id: "changeName",
      type: "function",
      // $item brings the current element data of the iterated array,
      handler: "$item.firstName = model.inputValue;",
    },
    {
      id: "displayFirstName",
      type: "function",
      handler:
        "console.log('$item',$item); model.activePersonID = $item.id; console.log('$model',model) ",
    },
    {
      id: "showModel",
      type: "function",
      handler: "console.log('model',model);console.log('item',$item);",
    },
  ];

  modelObject = {
    people: [],
    activePersonID: "",
    activePerson: null,
    inputValue: 5,
  };

  // - code starts here
  var viewModel = {},
    ko = require("knockout"),
    widgetUtils = require("common-ui/widgets/widgetUtils");
  ko.options.useOnlyNativeEvents = true;

  renderJSON = function () {
    let outputContainer = $("#output");
    let modelDefinition = JSON.parse(viewModel.textAreas.modelDefinition.value);
    let modelObject = JSON.parse(viewModel.textAreas.modelObject.value);
    buildRootModel(modelDefinition, modelObject);
    let json = JSON.parse(viewModel.textAreas.jsonInput.value);
    outputContainer.removeAttr("style");
    outputContainer.empty();
    let container = buildContainerElement(
      "",
      outputContainer,
      json,
      viewModel,
      true
    );
    ko.applyBindings(rootModel, container);
    outputContainer.append(container);
  };

  viewModel.activate = function () {
    let self = this;
    this.textAreas = {
      jsonInput: {
        id: "jsonInput",
        value: JSON.stringify(defaultJson, undefined, 4),
        cols: 30,
        rows: 20,
      },
      modelDefinition: {
        id: "modelDefinition",
        value: JSON.stringify(modelDefinition, undefined, 4),
        cols: 25,
        rows: 20,
      },
      modelObject: {
        id: "modelObject",
        value: JSON.stringify(modelObject, undefined, 4),
        cols: 25,
        rows: 20,
      },
      // none: {
      //   id: "test1",
      //   value: '',
      //   cols: 0,
      //   rows: 0,
      // },
    };
    this.activeInput = ko.observable(this.textAreas.none);
    this.tabsSettings = {
      $color: null,
      $alignment: "left",
      $active: "none",
      $items: [
        { id: "jsonInput", icon: "zmdi-home", text: "JSON INPUT", content: "" },
        {
          id: "modelObject",
          icon: "",
          text: "Model Object",
          content: "",
        },
        {
          id: "modelDefinition",
          icon: "",
          text: "Model Definition",
          content: "",
        },
        {
          id: "none",
          icon: "",
          text: "None",
          content: "",
        },
      ],
      tabSelectedCallback: function (tab) {
        if (tab && tab.id) {
          switch (tab.id) {
            case "jsonInput":
              self.activeInput(self.textAreas.jsonInput);
              break;
            case "modelObject":
              self.activeInput(self.textAreas.modelObject);
              break;
            case "modelDefinition":
              self.activeInput(self.textAreas.modelDefinition);
              break;
            case "none":
              self.activeInput("");
              break;
          }
        }
      },
    };
  };
  return viewModel;
});

var rootModel = {};
var modelDefinition = {};

function removeAttributes(element) {
  for (let i = 0; i < element.attributes.length; i++) {
    element.removeAttribute(element.attributes[i].name);
  }
}

function removeChildElements(element) {
  var child = element.lastElementChild;
  while (child) {
    element.removeChild(child);
    child = element.lastElementChild;
  }
}

function renderButton(kind, color, click, id, text, icon, disabled) {
  return {
    kind: kind,
    color: color,
    click: click, //wrap for avoid context problems.
    id: id,
    text: text,
    icon: icon,
    disabled: disabled,
  };
}

class Model {
  constructor(modelObject) {
    let observables = {};
    for (let key in modelObject) {
      if (key != "__originalTarget") {
        if (isObject(modelObject[key]) && isArray(modelObject[key])) {
          observables[key] = ko.observableArray(modelObject[key]);
        } else {
          observables[key] = createObservable(modelObject[key]);
        }
      } else {
        observables[key] = modelObject[key];
      }
    }
    Object.assign(this, observables);
  }
}

class Record {
  constructor(data) {
    console.log("---------------------------------");

    console.log("building record ", data);
    let observables = {};
    observables = buildObservables(observables, data);
    console.log("building record output ", observables);
    console.log("---------------------------------");

    Object.assign(this, observables);
  }
}

function buildObservables(observables, data) {
  let observable;
  for (let key in data) {
    if (isObject(data[key]) && isArray(data[key])) {
      observable = ko.observableArray(buildObservables([], data[key]));
    } else if (isObject(data[key]) && data[key]) {
      if (data[key].name) {
        observable = createObservable(data[key].name);
      }
      // conditions met by relationship fields
      else if (
        Object.keys(data[key]).length == 2 &&
        data[key].label &&
        data[key].id
      ) {
        observable = createObservable(data[key].label);
      } else {
        observable = createObservable(buildObservables({}, data[key]));
      }
    } else {
      observable = createObservable(data[key]);
    }
    if (isObject(observables) && isArray(observables)) {
      observables.push(observable);
    } else {
      observables[key] = observable;
    }
  }
  console.log("observables ", observables);
  return observables;
}

function buildRootModel(modelDefinition, modelObject) {
  this.modelDefinition = modelDefinition;
  rootModel = buildModel(modelDefinition, modelObject);
  console.log("rootModel: ", rootModel);
}

function buildModel(modelDefinition, modelObject) {
  let model = {};
  for (key in modelObject) {
    let definition = findDefinitionKey(modelDefinition, key);
    if (definition) {
      validateKey(definition, key, modelObject[key], model);
    } else {
      alert("Var: " + key + " has not been defined");
      throw "Var: " + key + " has not been defined";
    }
  }
  for (definition in modelDefinition) {
    if (modelDefinition[definition].type == "function") {
      let handler = modelDefinition[definition].handler;
      model[modelDefinition[definition].id] = buildFunctionWithHelpers(handler);
    }
  }
  return model;
}

function buildFunctionWithHelpers(handler) {
  let parameters = ["$root", "model", "$item", "$index", "$parent", "$parents"];
  return function () {
    let newFunction = new Function(parameters, handler);
    let $data = arguments[0];
    let $root = rootModel;
    let $item =
      $data.settings && $data.settings.bindingContext
        ? $data.settings.bindingContext.$data
        : $data;
    let $parents =
      $data.settings && $data.settings.bindingContext
        ? $data.settings.bindingContext.$parents
        : null;
    let $index =
      $data.settings &&
      $data.settings.bindingContext &&
      $data.settings.bindingContext.$index
        ? $data.settings.bindingContext.$index()
        : null;
    // console.log("-------------------------------------");
    // console.log("args", arguments);
    // console.log("root", $root);
    // console.log("$data", $data);
    // console.log("item", $item);
    // console.log("are equal", $item === $root);
    // console.log("index", $index);
    // console.log("parents", $parents);
    let model = deepProxy(rootModel);
    if ($item) {
      if ($item === $root) {
        console.log("creating $item proxy", model);
        $item = model;
      } else {
        $item = deepProxy($item);
      }
      // $item = deepProxy($item);
    }
    let parentsProxies = [];
    let parent = null;
    console.log("parents", $parents);
    if ($parents) {
      $parents.forEach((context) => {
        console.log("creating $parents proxy", context);
        // we skip generating proxy for tabs context
        if (context.constructor.name !== "Tabs") {
          if (context === $root) {
            parentsProxies.push(model);
          } else {
            parentsProxies.push(deepProxy(context));
          }
        }
      });
      $root = parentsProxies[0];
      parent = parentsProxies[parentsProxies.length - 1];
    }
    console.log("parent proxies", parentsProxies);
    // console.log("PARENT PROXIES: ", parentsProxies);
    // if ($parents) $parents = deepProxy($parents);
    return newFunction($root, model, $item, $index, parent, parentsProxies);
  };
}

function isObject(obj) {
  return typeof obj === "object";
}
const arrayChangeMethod = [
  "push",
  "pop",
  "unshift",
  "shift",
  "splice",
  "sort",
  "reverse",
];
function isArray(arr) {
  return Array.isArray(arr);
}

let myProxySet = new WeakSet();

function deepProxy(model, target2) {
  // console.log("DEEP PROXY model ", model);
  // console.log("DEEP PROXY target2", target2);
  const mapStore = {};
  let arrayChanging = false;
  if (model && !myProxySet.has(model)) {
    // //we store the original model so we have access later to the original Model
    // model.__originalTarget = model;
    let proxy = new Proxy(model, {
      get(target, property, receiver) {
        if (
          typeof property == "symbol" ||
          property == "_destroy" ||
          property == "__ko_proto"
        )
          return target[property];
        // console.log("GET -----------------------------------");
        // console.log("GET target", target);
        // console.log("GET property", property);
        // console.log("GET typeof property ", typeof property);
        // console.log("GET receiver", receiver);
        // console.log("GET target[property]", target[property]);
        // console.log("GET target2", target2);
        let value = target[property];
        if (typeof target === "function" && target.name == "observable") {
          value = target()[property];
          // console.log("GET RETURNING target()[property]: ", value);
        } else if (
          typeof target[property] === "function" &&
          target[property].name == "observable"
        ) {
          value = target[property]();
          // console.log("GET RETURNING target[property](): ", value);
        } else {
          // console.log("GET RETURNING target[property]: ", value);
          // value = target[property];
        }
        if (isArray(target) && arrayChangeMethod.indexOf(property) > -1) {
          console;
          // we override the array's method
          return (...args) => {
            arrayChanging = true;
            // console.log("ARRAY METHOD args", ...args);
            // console.log("ARRAY METHOD Array property", property);
            // console.log("ARRAY METHOD Array receiver", receiver);
            // console.log("ARRAY METHOD Array value", value);
            // console.log("ARRAY METHOD Array target", target);
            // console.log("ARRAY METHOD Array target2", target2);
            // console.log("ARRAY METHOD Array target2", target2());
            value.bind(receiver)(...args);
            arrayChanging = false;
          };
        }
        console.log("GET value", value);

        if (mapStore[property] === true) return value;
        if (isObject(value) || isArray(value)) {
          // console.log("Recursive method: target ", target);
          // console.log("Recursive method: value ", value);
          // console.log("Recursive method: property ", property);
          // console.log("Recursive method: typeof property ", typeof property);
          // console.log("Recursive method: target[property] ", target[property]);
          // console.log(
          //   "Recursive method: mapStore[property] ",
          //   mapStore[property]
          // );
          // console.log("value: ", value);
          const proxyValue =
            mapStore[property] || deepProxy(value, target[property]);
          mapStore[property] = proxyValue;
          return proxyValue;
        }
        mapStore[property] = true;

        // console.log("GET value", value);
        // console.log("GET target", target);
        // console.log("GET property", property);
        // console.log("GET receiver", receiver);
        // console.log("GET target[property]", target[property]);
        return value;
      },
      set(target, property, value) {
        // console.log("SET ------------------------------------------");
        // console.log("SET value: ", value);
        // console.log("SET target", target);
        // console.log("SET property", property);
        // console.log("SET target[property]", target[property]);
        // console.log("SET target2", target2);
        // console.log("SET array changing", arrayChanging);
        let newVal = buildValueBeforeSet(value);
        // console.log("SET newVal", newVal);
        if (arrayChanging) console.log("array changing");
        if (typeof target2 === "function" && target2.name == "observable") {
          // console.log("SET target2 is observable..", newVal);
          target[property] = newVal;
          if (property !== "length") target2(target);
        } else if (
          typeof target[property] === "function" &&
          target[property].name == "observable"
        ) {
          console.log("SET target[property](newVal)", newVal);
          target[property](newVal);
        } else {
          console.log("SET target[property] = ", newVal);
          target[property] = newVal;
        }
        mapStore[property] = true;
        return true;
      },
      deleteProperty(target, property) {
        // console.log("DELETE target", target);
        // console.log("DELETE property", property);
        // console.log("DELETE target[property]", target[property]);
        // console.log("DELETE arguments", arguments);
        // console.log("DELETE target2", target2);
        // console.log("DELETE arrayChanging", arrayChanging);
        delete target[property];
        delete mapStore[property];
        // delete target[property];
        if (typeof target2 === "function" && target2.name == "observable") {
          // console.log("DELETE update observable", target2);
          // target2.remove(target[property]);
        }
        if (!arrayChanging) console.log("array changing");

        return true;
      },
    });
    myProxySet.add(proxy);
    console.log("MY PROXY ADDING", proxy);
    console.log("MY PROXY SET", myProxySet);
    //we store the original model so we have access later to the original Model
    proxy.__originalTarget = model;
    // model.__originalTarget = model;
    // delete model.__originalTarget
    return proxy;
  } else {
    console.log("Proxy exists", model);
    return model;
  }
}

function buildValueBeforeSet(value) {
  let newVal;
  if (value.constructor.name == "Tabs") return value;
  if (isObject(value)) {
    if (isArray(value)) {
      //we desestructure proxy objects so we set normal objects in de view model
      value = [...value];
      value.forEach((element, index) => {
        value[index] = buildValueBeforeSet(element);
      });
      // console.log("SET is array, returning value", value);
      // newVal = deepProxy(value, target2);
      delete value.__originalTarget;

      newVal = value;
    } else {
      // console.log("SET value.constructor.name", value.constructor.name);
      if (value.constructor.name == "Model") {
        //  if(value.__originalTarget) value = value.__originalTarget;
        // console.log("SET yyy value1 ", value);

        // value = {...value};
        // console.log("SET yyy value2 ", value);
        // console.log("SET yyy value.__originalTarget ", value.__originalTarget);
        newVal = value.__originalTarget ? value.__originalTarget : value;
        // console.log("SET yyy new val", newVal);
        delete newVal.__originalTarget;
        // console.log("SET is a model, not creating model", newVal);
        // newVal = value;
      } else {
        // console.log("SET is not a model, creating model", value);
        delete value.__originalTarget;
        newVal = new Model(value);
        // newVal = value;
      }
      Object.keys(newVal).forEach((key) => {
        newVal[key] = buildValueBeforeSet(newVal[key]);
      });
    }
  } else {
    newVal = value;
  }
  // newVal = value;
  // console.log("yyy SET...newValue", newVal);
  return newVal;
}
function findDefinitionKey(modelDefinition, key) {
  let definition;
  modelDefinition.map((object) => {
    if (object.id === key) {
      definition = object;
    }
  });
  return definition;
}

function validateKey(definition, key, value, model) {
  let valid = false;
  switch (definition.type) {
    case "string":
    case "number":
      if (typeof value == definition.type) {
        if (model) model[key] = createObservable(value);
        valid = true;
      }
      break;
    case "boolean":
      if (typeof value == "boolean") {
        if (model) model[key] = createObservable(value);
        valid = true;
      }
      break;
    case "array":
      let array = [];
      model[key] = ko.observableArray();
      if (definition.elementsType !== "record") {
        array = validateArray(value, definition);
        if (model) {
          model[key](array);
          console.log("modelkey: ", model[key]());
        }
      } else {
        console.log("fetching: ");
        slingr.ws.get(
          {
            url: "/data/" + definition.query.entity,
            params: { _size: definition.query.size },
          },
          function (res) {
            console.log("fetching: ", res);
            res.items.forEach((item) => {
              array.push(new Model(item));
            });
            model[key](array);
          }
        );
      }
      valid = true;
      break;
    case "JSON":
      console.log("JSON value", value);
      if (model) model[key] = createObservable(value);
      valid = true;
      break;
    case "model":
      if (model) {
        if (value) {
          let submodel = validateModel(value, definition.nestedFields);
          model[key] = ko.observable(new Model(submodel));
        } else {
          model[key] = ko.observable();
        }
      }
      if (model) {
        if (value) {
          // model[key] = ko.observable(deepProxy(new Model(value)));
          // model[key] = ko.observable(new Model(value));
        } else {
          console.log("empty observable: ", definition);
          // model[key] = ko.observable();
        }
      }
      valid = true;
      break;
    case "record":
      valid = true;
      break;
  }
  if (!valid) {
    noValidTypeError(key, typeof value, definition);
  }
  return valid;
}
function createObservable(value) {
  if (typeof value == "function" && value.name == "observable") {
    return value;
  } else {
    return ko.observable(value);
  }
}

function validateArray(array, arrayDefinition) {
  let data = [];
  for (element in array) {
    if (
      arrayDefinition.elementsType == "model" ||
      arrayDefinition.elementsType == "JSON"
    ) {
      let model = {};
      for (key in array[element]) {
        let definition = findDefinitionKey(arrayDefinition.nestedFields, key);
        if (definition) {
          validateKey(definition, key, array[element][key], model);
        } else {
          alert("Var: " + key + " has not been defined");
          throw "Var: " + key + " has not been defined";
        }
      }
      // ***
      // data.push(deepProxy(model));
      console.log("modelToPush", model);
      // data.push(deepProxy(new Model(model)));
      data.push(new Model(model));
    } else {
      validateKey(
        { id: "arrayElement", type: arrayDefinition.elementsType },
        arrayDefinition.id,
        array[element]
      );
      data.push(element);
    }
  }
  return data;
}

function validateModel(modelObject, nestedFields) {
  let model = {};
  for (key in modelObject) {
    let definition = findDefinitionKey(nestedFields, key);
    if (definition) {
      console.log("modelObject[key]", modelObject[key]);
      validateKey(definition, key, modelObject[key]);
      model[key] = modelObject[key];
    } else {
      alert("key: " + key + "is not defined");
      throw "key: " + key + "is not defined";
    }
  }
  return model;
}

function noValidTypeError(key, currentType, definition) {
  alert(
    "wrong type of key:  " +
      key +
      ". It is a: " +
      currentType +
      " and should be a: " +
      definition.type
  );
  throw (
    "wrong type of key:  " +
    key +
    ". It is a: " +
    currentType +
    " and should be a: " +
    definition.type
  );
}

function buildContainerElement(parentObject, parentElement, elementObject) {
  let container = document.createElement("div");
  if (elementObject.type == "formGroup") container.classList.add("form-group");
  container = setWidgetCss(
    parentObject,
    parentElement,
    elementObject,
    container
  );
  buildChildWidgets(elementObject, container);
  checkIfBindings(elementObject, container);
  return container;
}

function buildTabsElement(parentObject, parentElement, elementObject) {
  let container = document.createElement("div");
  container = setWidgetCss(
    parentObject,
    parentElement,
    elementObject,
    container
  );
  let tabContainer = createHtmlNode("div", { "data-part": "content" });
  container.append(tabContainer);
  elementObject.properties.tabs.forEach((tab) => {
    let ifContainer = createHtmlNode("div", {
      "data-bind": "if: id == '" + tab.id + "'",
    });
    buildChildWidgets(tab, ifContainer);
    tabContainer.append(ifContainer);
  });
  checkIfBindings(elementObject, container);
  return container;
}

function buildChildWidgets(elementObject, container) {
  elementObject.widgets.forEach(function (childElement) {
    let widget;
    switch (childElement.type) {
      case "formGroup":
      case "container":
        widget = buildContainerElement(
          elementObject,
          container,
          childElement,
          true
        );
        break;
      case "tabs":
        widget = buildTabsElement(elementObject, container, childElement);
        break;
      case "repeatedContainer":
        widget = buildRepeatedContainerElement(
          elementObject,
          container,
          childElement,
          false
        );
        break;
      case "table":
        widget = buildTableElement(elementObject, container, childElement);
        break;
      case "readOnly":
        console.log("readonly childElement", childElement);
        childElement.subtype = "readOnly";
        widget = buildRecordWidget(elementObject, container, childElement);
        break;
      case "edit":
        console.log("edit childElement", childElement);
        childElement.subtype = "edit";
        widget = buildRecordWidget(elementObject, container, childElement);
        break;
      case "recordContainer":
        widget = buildRecordContainerElement(
          elementObject,
          container,
          childElement
        );
        break;
      case "recordField":
        if (childElement.properties.field) {
          widget = buildLabelValueGrid(childElement.properties.field);
          widget = setWidgetCss(elementObject, container, childElement, widget);
        } else {
          console.log("not field provided!!");
          return;
        }
        break;
      case "slingrWidget":
      default:
        widget = buildWidgetElement(elementObject, container, childElement);
        checkIfBindings(childElement, widget);
    }
    if (childElement.if || childElement.with) {
      let prop = childElement.if ? "if" : "with";
      widget = wrapIfWithContainer(prop, childElement, widget);
      widget.setAttribute("style", "display:" + elementObject.layout.display);
    }
    container.appendChild(widget);
  });
}

function wrapIfWithContainer(key, childElement, widget) {
  let ifContainer;
  let value = checkBinding({}, key, childElement[key]);
  let observable = buildKnockoutHTMLBinding(value);
  console.log("childe element: ", childElement);
  ifContainer = createHtmlNode("div", { "data-bind": key + ":" + observable });
  ifContainer.append(widget);
  return ifContainer;
}

function buildRecordContainerElement(
  parentObject,
  parentElement,
  elementObject
) {
  let containerID = uuidv4();
  console.log("generated ID", containerID);
  let container = createHtmlNode("div", { id: containerID });
  container = setWidgetCss(
    parentObject,
    parentElement,
    elementObject,
    container
  );
  container.style.overflowY = "scroll";
  let recordId = elementObject.recordId;
  if (isBinding(recordId)) {
    recordId = buildKnockoutHTMLBinding(recordId);
    console.log("IS BINDING", recordId);
  }
  rootModel[recordId].subscribe(function (newValue) {
    console.log("arguments: ", arguments);
    console.log("this: ", this);
    slingr.ws.post(
      {
        url:
          "/ui/default/views/5ebc7aa1dd8c0e5ef66b8df9/readOnly?_recordId=" +
          newValue +
          "&_fullViewInfo=true",
      },
      {},
      function (res) {
        console.log("buildReadOnlyContainerElement record: ", res);
        container = document.getElementById(containerID);
        removeChildElements(container);

        complementWidgetsElementsWithResponse(
          elementObject,
          res,
          elementObject.subtype
        );
        hitDataApi(newValue, function (res) {
          console.log("recordData", res);
          let aModel = new Model(res);
          console.log("new model, ", aModel);
          console.log("rootModel, ", rootModel);
          console.log("elementObject", elementObject);
          rootModel[elementObject.output.record] = aModel;

          let extendedContextContainer = createHtmlNode("div", {
            "data-bind": "withProperties:" + elementObject.output.record,
          });

          buildChildWidgets(elementObject, extendedContextContainer);
          // removeChildElements(container);
          // res.fields.forEach((field) => {
          //   buildLabelValueGrid(container, field);
          // });
          console.log("apply bindings");
          container.append(extendedContextContainer);
          ko.applyBindingsToDescendants(rootModel, container);
        });
      }
    );
  });
  checkIfBindings(elementObject, container);
  console.log("buildReadOnlyContainerElementCONTAINER", container);

  return container;
}
function uuidv4() {
  return ([1e7] + 1e3 + 4e3 + 8e3 + 1e11).replace(/[018]/g, (c) =>
    (
      c ^
      (crypto.getRandomValues(new Uint8Array(1))[0] & (15 >> (c / 4)))
    ).toString(16)
  );
}
function complementWidgetsElementsWithResponse(elementObject, res, type) {
  elementObject.widgets.forEach((widgetObject) => {
    if (widgetObject.type == "recordField") {
      let field = res.fields.find((field) => field.name == widgetObject.field);
      if (field) {
        Object.assign(field.options, widgetObject.properties);
        widgetObject.properties.field = { ...field };
        widgetObject.properties.field.subtype = type;
      } else {
        console.log("no field founded for:", widgetObject);
      }
    }
    if (widgetObject.widgets) {
      complementWidgetsElementsWithResponse(widgetObject, res, type);
    } else if (widgetObject.type == "tabs") {
      widgetObject.properties.tabs.forEach((tab) => {
        complementWidgetsElementsWithResponse(tab, res, type);
      });
    }
  });
}

function hitDataApi(id, callback) {
  slingr.ws.get({ url: "/data/sys.users/" + id }, callback);
}

function buildRecordWidget(parentObject, parentElement, elementObject) {
  let container = document.createElement("div");
  container = setWidgetCss(
    parentObject,
    parentElement,
    elementObject,
    container
  );
  let containerID = crypto.getRandomValues(new Uint32Array(10));
  container.setAttribute("id", containerID);
  console.log("generated ID", containerID);
  console.log("buildReadOnlyContainerElement");
  container.style.overflowY = "scroll";
  let recordId = elementObject.recordId;
  if (isBinding(recordId)) {
    recordId = buildKnockoutHTMLBinding(recordId);
    console.log("IS BINDING", recordId);
  }
  if (
    typeof rootModel[recordId] === "function" &&
    rootModel[recordId].name == "observable"
  ) {
    rootModel[recordId].subscribe(function (newValue) {
      console.log("arguments: ", arguments);
      console.log("this: ", this);
      slingr.ws.post(
        {
          url:
            "/ui/default/views/5ebc7aa1dd8c0e5ef66b8df9/readOnly?_recordId=" +
            newValue +
            "&_fullViewInfo=true",
        },
        {},
        function (res) {
          container = document.getElementById(containerID);
          console.log("buildReadOnlyElement record: ", res);
          removeChildElements(container);
          if (elementObject.type == "edit") {
            hitDataApi(newValue, function (recordData) {
              console.log("elementObject", elementObject);
              console.log("recordData", recordData);
              let recordModel = new Record(recordData);
              console.log("newRecord, ", recordModel);
              console.log("rootModel, ", rootModel);
              rootModel[elementObject.output.record] = recordModel;

              let extendedContextContainer = createHtmlNode("div", {
                "data-bind": "withProperties:" + elementObject.output.record,
              });

              container.append(extendedContextContainer);
              res.fields.forEach((field) => {
                field.subtype = elementObject.subtype;
                extendedContextContainer.append(buildLabelValueGrid(field));
                extendedContextContainer.appendChild(
                  document.createElement("br")
                );
              });
              ko.applyBindingsToDescendants(rootModel, container);
            });
          } else {
            res.fields.forEach((field) => {
              field.subtype = elementObject.subtype;
              container.append(buildLabelValueGrid(field));
              container.appendChild(document.createElement("br"));
            });
          }
        }
      );
    });
  }
  console.log("readonly element", arguments);
  checkIfBindings(elementObject, container);
  return container;
}

function buildLabelValueGrid(field, parents) {
  let fieldContainer = createHtmlNode(
    "div",
    { style: "padding: 8px;border-style: dotted; margin: 3px;" },
    ["row"]
  );
  if (field) {
    if (field.options.showLabel) {
      let fieldLabelCol = createHtmlNode(
        "div",
        { style: "text-align: right;" },
        ["col-xs-3"]
      );
      let fieldLabel = createHtmlNode("div", {
        style: "padding: 3px; margin: 6px;font-weight:900; text-align:right",
      });
      let label = field.label;
      fieldLabel.innerHTML = label + ":";
      fieldLabelCol.append(fieldLabel);
      fieldContainer.append(fieldLabelCol);
    }
    let fieldValueCol = buildValueColumn(field, parents);
    fieldContainer.append(fieldValueCol);
  } else {
    throw "empty field to build method";
  }
  return fieldContainer;
}

function buildValueColumn(field, parentsParam) {
  let parents = parentsParam;
  let fieldValueCol = document.createElement("div");
  fieldValueCol.classList.add(
    field.options.showLabel ? "col-xs-9" : "col-xs-12"
  );
  value = field.formattedValue ? field.formattedValue : field.value;
  if (field.type == "NESTED_FIELDS") {
    if (field.multiplicity == "ONE") {
      buildNestedFieldsLabel(fieldValueCol, value.systemFields, field.options);
      let parentName = field.name;
      value.nestedFields.forEach((nestedField) => {
        nestedField.subtype = field.subtype;
        if (parents) {
          let updated = false;
          console.log("nestedField before parents:", parents);
          parents = parents.map((parent) => {
            console.log("nestedField child parent:", parent);
            if (
              parent[0] == "nestedField" &&
              parent[1] == parentName
            ) {
              updated = true;
              return ["nestedField", parentName];
            }
            return parent;
          });
          if (!updated) {
            console.log("nestedField Pushing Parent", parentName);
            parents.push(["nestedField", parentName]);
          } else {
            console.log("nestedFieldPARENTS UPDATED: ", parents);
          }
          console.log("nestedFieldPARENTS: ", parents);
        } else {
          console.log("nestedField creating Parent", parentName);
          parents = [["nestedField", parentName]];
        }
        fieldValueCol.append(buildLabelValueGrid(nestedField, parents));
        fieldValueCol.appendChild(document.createElement("br"));
      });
    } else if (value) {
      let parentName = field.name + "()";
      value.forEach((childValue, index) => {
        let valueElement = createHtmlNode("div", {
          style: "padding: 2px;border-style: dotted;",
        });
        parents = processParents(parents, parentName, "nestedField", index);
        buildNestedFieldsLabel(
          valueElement,
          childValue.systemFields,
          field.options
        );
        childValue.nestedFields.forEach((nestedField) => {
          nestedField.subtype = field.subtype;
          valueElement.append(buildLabelValueGrid(nestedField, parents));
          valueElement.appendChild(document.createElement("br"));
        });
        fieldValueCol.append(valueElement);
        fieldValueCol.appendChild(document.createElement("br"));
      });
    }
  } else {
    if (field.multiplicity == "MANY" && value) {
      let parentName = field.name + "()";
      // parents.push(["array", parentName, 0]);
      value.forEach((value, index) => {
        parents = processParents(parents, parentName,"array", index);
        buildValueElement(value, fieldValueCol, field, parents);
      });
    } else {
      console.log("ONE notNested", field);
      buildValueElement(value, fieldValueCol, field, parents);
    }
  }
  return fieldValueCol;
}

function processParents(parents, parentName, type, index) {
  let updated = false;
  let parent0=[type, parentName];
  if (index) parent0.push(index);
  if (parents) {
    console.log(type+" before parents:", parents);
    parents = parents.map((parent) => {
      if (
        parent[0] == type &&
        parent[1] == parentName 
      ) {
        if(index && parent[2] == index - 1 ) {
          updated = true;
          return [type, parentName, index];
        }
      }
      return parent;
    });
    if (!updated) {
      console.log(type+" Pushing Parent", parentName);
      parents.push(parent0);
    } else {
      console.log(type+" PARENTS UPDATED: ", parents);
    }
    console.log(type+ " PARENTS: ", parents);
  } else {
    console.log(type+ "creating Parent", parentName);
    parents = [parent0];
  }
  return parents;
}


function buildNestedFieldsLabel(element, systemFields, options) {
  if (systemFields && options.showAsAccordion) {
    let label = createHtmlNode("div", {
      style: "padding: 3px; margin: 6px;font-weight:900;",
    });
    label.innerHTML = systemFields.label;
    element.append(label);
  }
}

function buildValueElement(value, fieldValueCol, field, parents) {
  let fieldValue;

  if (field.subtype == "readOnly") {
    fieldValue = createHtmlNode("div", {
      style: "padding: 3px;  margin: 6px",
    });
    fieldValue.innerHTML = value;
  } else if (field.subtype == "edit") {
    console.log("FIELD edit: ", field);
    let name = "";
    console.log("PARENT", parents);
    if (parents) {
      parents.forEach((parent) => {
        let parentString = parent[1];
        parentString =
          parent[2] || parent[2] == 0
            ? parent[1] + "[" + parent[2] + "]"
            : parent[1];
        parentString += ".";
        name += parentString;
      });
      if (parents[parents.length - 1][0] == "nestedField") {
        name += field.name;
      } else {
        name = name.slice(0, -1);
      }
    } else {
      name = field.name;
    }
    console.log("value edit : ", value);
    let inputElement = {
      id: "inputTextSlingr",
      type: "slingrWidget",
      visible: true,
      properties: {
        kind: "inputText",
        id: "titleInput",
        placeholder: field.name,
        // value: "{{" + field.name + "}}",
        // value: "" + name + "",
        value: "{{" + name + "}}",
        password: null,
        icon: null,
        //  maxLength: 10,
      },
      layout: {},
      style: {
        width: "",
      },
    };
    fieldValue = buildWidgetElement(null, fieldValueCol, inputElement);
    checkIfBindings(inputElement, fieldValue);
  }

  fieldValueCol.append(fieldValue);
}

function buildRepeatedContainerElement(
  parentObject,
  parentElement,
  elementObject
) {
  let container = document.createElement("div");
  container = setWidgetCss(
    parentObject,
    parentElement,
    elementObject,
    container
  );
  let repeatedContainer = document.createElement(
    elementObject.properties.repeatedContainer.type
  );
  repeatedContainer = setWidgetCss(
    elementObject,
    container,
    elementObject.properties.repeatedContainer,
    repeatedContainer
  );
  buildChildWidgets(
    elementObject.properties.repeatedContainer,
    repeatedContainer,
    null
  );
  checkIfBindings(
    elementObject.properties.repeatedContainer,
    repeatedContainer
  );
  container.append(repeatedContainer);
  checkIfBindings(elementObject, container, true);
  return container;
}

function buildTableElement(parentObject, parentElement, elementObject) {
  let table = document.createElement("table");
  table.classList.add("table");
  table = setWidgetCss(parentObject, parentElement, elementObject, table);
  elementObject.properties.tableTypes.forEach((element) => {
    table.classList.add(element);
  });
  let thead = document.createElement("thead");
  let theadRow = document.createElement("tr");
  let tbody = document.createElement("tbody");
  let tbodyRow = document.createElement("tr");
  for (column in elementObject.properties.columns) {
    //build header
    buildTablePart(
      elementObject.properties.columns[column].header,
      theadRow,
      "header"
    );
    //build tbody
    buildTablePart(
      elementObject.properties.columns[column].cell,
      tbodyRow,
      "tbody"
    );
  }
  thead.append(theadRow);
  table.append(thead);
  tbody.append(tbodyRow);
  let data;
  if (isBinding(elementObject.data)) {
    data = buildKnockoutHTMLBinding(elementObject.data);
  }
  tbody.setAttribute("data-bind", "foreach:" + data);
  table.append(tbody);
  return table;
}

function buildTablePart(element, tr, tablePart) {
  let telement;
  if (tablePart == "header") {
    telement = createHtmlNode("th", { scope: "col" });
  } else if (tablePart == "tbody") {
    telement = createHtmlNode(
      element.type,
      element.type == "th" ? { scope: "row" } : null
    );
  }
  buildChildWidgets(element, telement, false, null);
  setWidgetCss("", "", element, telement);
  checkIfBindings(element, telement);
  tr.append(telement);
}

function buildWidgetElement(parentObject, parentElement, elementObject) {
  let elementType =
    elementObject.type == "slingrWidget" ? "div" : elementObject.type;
  let widget = createHtmlNode(elementType, { id: elementObject.id });
  switch (elementObject.type) {
    case "button":
      widget.classList.add("btn");
      widget.classList.add(elementObject.properties.class);
      break;
    case "input":
      widget.classList.add("form-control");
      widget = setInputProp(elementObject, widget);
      break;
  }
  widget = setWidgetCss(parentObject, parentElement, elementObject, widget);
  widget = setTextProp(elementObject, widget);
  return widget;
}

function setInputProp(elementObject, widget) {
  widget.setAttribute("type", elementObject.properties.type);
  if (elementObject.properties.placeholder) {
    widget.setAttribute("placeholder", elementObject.properties.placeholder);
  }
  if (elementObject.properties.value) {
    widget.value = elementObject.properties.value;
  }
  return widget;
}

function setTextProp(elementObject, widget) {
  if (elementObject.font) {
    Object.assign(widget.style, {
      "text-align": elementObject.layout.textAlign,
      "text-decoration-line": elementObject.layout.textDecorationLine,
      "text-transform": elementObject.layout.textTransform,
      "letter-spacing": elementObject.layout.letterSpacing,
      "line-height": elementObject.layout.lineHeight,
      color: elementObject.font.color,
      "font-family": elementObject.font.fontFamily
        ? elementObject.font.fontFamily
        : null,
      "font-style": elementObject.font.fontStyle,
      "font-size": elementObject.font.fontSize,
      "font-weight": elementObject.font.fontWeight,
    });
  }
  if (
    elementObject.text &&
    !isBinding(elementObject.text) &&
    elementObject.text.indexOf("$") == -1
  ) {
    widget.innerHTML = elementObject.text;
  }
  return widget;
}

function setWidgetCss(parentObject, parentElement, elementObject, widget) {
  Object.assign(widget.style, {
    width: elementObject.style.width,
    "min-width": elementObject.style.minWidth,
    "max-width": elementObject.style.maxWidth,
    "min-height": elementObject.style.minHeight,
    "max-height": elementObject.style.maxHeight,
    height: elementObject.style.height,
    display: elementObject.layout.display,
    verticalAlign: elementObject.layout.verticalAlign,
    "flex-direction": elementObject.layout.flexDirection,
    "justify-content": elementObject.layout.justifyContent,
    "flex-shrink": elementObject.layout.flexShrink,
    gap: elementObject.layout.gap,
    "padding-top": elementObject.layout.paddingTop,
    "padding-bottom": elementObject.layout.paddingBottom,
    "padding-right": elementObject.layout.paddingRight,
    "padding-left": elementObject.layout.paddingLeft,
    "margin-top": elementObject.layout.marginTop,
    "margin-bottom": elementObject.layout.marginBottom,
    "margin-right": elementObject.layout.marginRight,
    "margin-left": elementObject.layout.marginLeft,
    "background-color": elementObject.style.backgroundColor,
    "border-style": elementObject.style.borderStyle,
    "border-color": elementObject.style.borderColor,
  });
  widget = setRowColumnLayout(parentObject, parentElement, widget);
  return widget;
}

function setRowColumnLayout(parentObject, parentElement, widget) {
  console.log();
  if (parentObject && parentObject.layout) {
    if (parentObject.layout.flexDirection == "column") {
      switch (parentObject.layout.columnPosition) {
        case "left":
          Object.assign(widget.style, {
            "margin-right": "auto",
          });
          break;
        case "right":
          Object.assign(widget.style, {
            "margin-left": "auto",
          });
          break;
        case "center":
          Object.assign(widget.style, {
            "margin-left": "auto",
            "margin-right": "auto",
          });
          break;
      }
    } else if (parentObject.layout.flexDirection == "row") {
      Object.assign(parentElement.style, {
        "align-items": parentObject.layout.alignItems,
        "flex-wrap": parentObject.layout.flexWrap,
      });
    }
  }
  return widget;
}

function checkIfBindings(elementObject, widget, forEachBinding) {
  let  styleBindedAttributes = {};
  let otherAttributes = {};
  for (key in elementObject.style) {
    checkBinding(styleBindedAttributes, key, elementObject.style[key]);
  }
  for (key in elementObject.layout) {
    checkBinding(styleBindedAttributes, key, elementObject.layout[key]);
  }
  for (key in elementObject.font) {
    checkBinding(styleBindedAttributes, key, elementObject.font[key]);
  }
  checkBinding(otherAttributes, "text", elementObject.text);
  checkBinding(otherAttributes, "visible", elementObject.visible);
  if (forEachBinding)
    checkBinding(otherAttributes, "foreach", elementObject.data);
  // slingr widgets handlers are processed in createSlingrWidgetBindingString()
  if (elementObject.handlers && elementObject.type !== "slingrWidget") {
    Object.keys(elementObject.handlers).forEach((event) => {
      if (isBinding(elementObject.handlers[event]))
        otherAttributes[event] = elementObject.handlers[event];
    });
  }
  let slingrWidgetbinding;
  if (elementObject.type == "slingrWidget") {
    let properties = elementObject.properties;
    slingrWidgetbinding = createSlingrWidgetBindingString(
      properties,
      elementObject
    );
  } else if (elementObject.type == "tabs") {
    let properties = buildTabsProperties(elementObject);
    slingrWidgetbinding = createSlingrWidgetBindingString(
      properties,
      elementObject
    );
  } else {
    for (key in elementObject.properties) {
      if (isBinding(elementObject.properties[key])) {
        otherAttributes[key] = elementObject.properties[key];
      }
    }
  }
  if (
    Object.keys(styleBindedAttributes).length !== 0 ||
    slingrWidgetbinding ||
    Object.keys(otherAttributes).length !== 0
  ) {
    createBindings(
      styleBindedAttributes,
      otherAttributes,
      slingrWidgetbinding,
      widget
    );
    return true;
  } else {
    return false;
  }
}

function buildTabsProperties(elementObject) {
  let items = [];
  elementObject.properties.tabs.forEach((tab) => {
    items.push({
      id: tab.id,
      icon: "",
      text: tab.text,
      content: "",
      callback: tab.handlers.activate,
    });
  });
  return {
    color: null,
    alignment: elementObject.properties.alignment,
    active: elementObject.properties.active,
    items: items,
    tabSelectedCallback: function (data) {
      let func = buildTabFunction(data);
      return func();
    },
  };
}
function buildTabFunction(data) {
  let parameters = ["$data", "model"];
  return function () {
    let newFunction = new Function(parameters, data.callback);
    delete data.callback;
    let $root = rootModel;
    let model = deepProxy(rootModel);
    return newFunction(data, model);
  };
}

function checkBinding(attributesObject, key, input) {
  let binding = isBinding(input);
  if (binding) {
    attributesObject[key] =
      binding == "observable" ? input : createComputedObservable(input);
  }
  return attributesObject[key];
}

function isBinding(input) {
  if (
    input &&
    input !== undefined &&
    typeof input == "string" &&
    input.match(/{{(.*?)}}/g)
  ) {
    let inputBindings = input.match(/{{(.*?)}}/g);
    if (inputBindings.length == 1 && !input.replace(inputBindings[0], "")) {
      return "observable";
    } else {
      return "computedObservable";
    }
  } else {
    return "";
  }
}

function createBindings(
  styleBindedAttributes,
  otherAttributes,
  slingrWidgetbinding,
  widget
) {
  let array = [];
  if (Object.keys(styleBindedAttributes).length !== 0)
    array.push(createStyleBindingString(styleBindedAttributes));
  if (Object.keys(otherAttributes).length !== 0)
    array.push(createOtherBindingString(otherAttributes));
  if (slingrWidgetbinding) array.push(slingrWidgetbinding);
  widget.setAttribute("data-bind", array.join(", "));
}

function createStyleBindingString(attributes) {
  stringifiedAttributes = "";
  let array = [];
  for (key in attributes) {
    if (attributes[key] && typeof attributes[key] === "string") {
      observable = buildKnockoutHTMLBinding(attributes[key]);
      let htmlProp = getHTMLProp(key);
      array.push("'" + htmlProp + "'" + ": " + observable);
    }
  }
  return "style: {" + array.join(", ") + "}";
}

function createSlingrWidgetBindingString(properties, elementObject) {
  let bindingString =
    elementObject.type == "slingrWidget" ? "widget: {" : "tabs:{";
  let array = [];
  for (key in properties) {
    let widgetParameter = processWidgetProperties(properties, key);
    array.push(key + ":" + widgetParameter);
  }
  if (elementObject.handlers) {
    let widgetParameter = processWidgetProperties(
      elementObject.handlers,
      "click"
    );
    array.push("click:" + widgetParameter);
  }
  bindingString += array.join(", ") + "}";
  return bindingString;
}

function processWidgetProperties(properties, key) {
  let widgetParameter;
  let propertyBinding = isBinding(properties[key]);
  if (propertyBinding) {
    let binding =
      propertyBinding == "observable"
        ? properties[key]
        : createComputedObservable(properties[key], elementObject.id);
    widgetParameter = buildKnockoutHTMLBinding(binding);
    if (key == "click") widgetParameter = "$root." + widgetParameter;
  } else if (key == "click") {
    let handler = properties[key];
    console.log("setting function ", modelDefinition[definition].id);
    widgetParameter = buildFunctionWithHelpers(handler);
  } else {
    widgetParameter =
      typeof properties[key] == "string"
        ? "'" + properties[key] + "'"
        : properties[key];
  }
  if (typeof widgetParameter == "object") {
    widgetParameter = JSON.stringify(widgetParameter);
  }
  return widgetParameter;
}

function createOtherBindingString(attributes) {
  stringifiedAttributes = "";
  let array = [];
  for (key in attributes) {
    if (attributes[key] && typeof attributes[key] === "string") {
      let observable = buildKnockoutHTMLBinding(attributes[key]);
      if (key == "keypress") {
        array.push("event:{" + key + ": " + observable + "}");
      } else if (key == "click") {
        array.push(key + ": $root." + observable);
      } else {
        array.push(key + ": " + observable);
      }
    }
  }
  if (array.length == 0) {
    return "";
  } else {
    return array.join(", ");
  }
}

function createComputedObservable(binding) {
  let bindings = binding.match(/{{(.*?)}}/g);
  let value = binding;
  bindings.forEach((element) => {
    let param = buildKnockoutHTMLBinding(element);
    let observableValue = param.indexOf(".length") != -1 ? param : param + "()";
    value = value.replace(element, observableValue);
  });
  return value;
}

function buildKnockoutHTMLBinding(binding) {
  if (typeof binding == "string") {
    let bindingMatch = binding.match(/{{(.*?)}}/);
    if (bindingMatch && bindingMatch.length > 0) {
      bindingMatch =
        typeof bindingMatch == "object" ? bindingMatch[1] : bindingMatch;
      bindingMatch = bindingMatch.replace(".", "().");
      bindingMatch = bindingMatch.replace("length()", "length");
      bindingMatch = bindingMatch.replace("model().", "$root.");
      bindingMatch = bindingMatch.replace("parent().", "$parent.");
      // binding = binding.replace("model.", "$root.");
      // binding = binding.replace("parent.", "$parent.");
      binding = bindingMatch;
    }
  }
  return binding;
}

function getHTMLProp(input) {
  switch (input) {
    case "minWidth":
      return "min-width";
    case "maxWidth":
      return "max-width";
    case "minWidth":
      return "min-width";
    case "minHeight":
      return "min-height";
    case "maxHeight":
      return "max-height";
    case "flexDirection":
      return "flex-direction";
    case "flexShrink":
      return "flex-shrink";
    case "paddingTop":
      return "padding-top";
    case "paddingBottom":
      return "padding-top";
    case "paddingTop":
      return "padding-bottom";
    case "paddingRight":
      return "padding-right";
    case "paddingLeft":
      return "padding-left";
    case "marginTop":
      return "margin-top";
    case "marginBottom":
      return "margin-bottom";
    case "marginRight":
      return "margin-right";
    case "marginLeft":
      return "margin-left";
    case "backgroundColor":
      return "background-color";
    case "borderStyle":
      return "border-style";
    case "borderColor":
      return "border-color";
    case "verticalAlign":
      return "vertical-align";
    default:
      return input;
  }
}

function createHtmlNode(type, attributes, classes) {
  let element = document.createElement(type);
  if (attributes)
    Object.keys(attributes).forEach((attribute) =>
      element.setAttribute(attribute, attributes[attribute])
    );
  if (classes) classes.forEach((el) => element.classList.add(el));
  return element;
}
